{
  "hash": "4069ed0f2b9975933ac54186ae280c81",
  "result": {
    "markdown": "---\ntitle: \"Practice spatial operations with the sf, tigris, and crashapi packages\"\neditor: visual\nknitr: \n  opts_chunk: \n    collapse: true\nexecute: \n  echo: true\n---\n\n\nThis exercise is designed to be used as an interactive activity to better understand how to work with spatial transformation functions from the sf package. A few suggestions:\n\n-   Questions that require you to figure out a function call before continuing are marked with a ü§î emoji.\n\n-   Try not to skip ahead because the answers to earlier questions are sometimes revealed by code later in the document. üòâ\n\n-   If you get stuck, explore the {sf} package documentation or take a look at the [{sf} cheatsheet](https://github.com/rstudio/cheatsheets/blob/main/sf.pdf) (This exercise also organizes the functions using the same categories as the cheatsheet).\n\n-   If you are submitting a completed exercise for the course, please make sure to check that the document renders without errors before committing an updated file to your course repository. üí™üèº\n\n## Getting started\n\n### Loading packages\n\nFirst we need to load a few packages:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tmap)\nlibrary(sf)\nlibrary(dplyr)\n```\n:::\n\n\n### Downloading data\n\nThen, we can download the counties with `tigris::counties()` and then filter to those counties in the [Baltimore--Columbia--Towson Metropolitan Statistical Area](https://en.wikipedia.org/wiki/Baltimore_metropolitan_area).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Set the state abbreviation \nmd <- \"MD\"\n\n# Get the counties with tigris::counties()\nmd_counties <- tigris::counties(state = md, cb = TRUE)\n\n# FIPS codes for the counties in the Baltimore MSA\nmsa_fips <- c(\"510\", \"005\", \"013\", \"003\", \"027\", \"035\", \"025\")\n\n# Filter to the counties in the Baltimore MSA\nmsa_counties <-\n  filter(\n    md_counties,\n    COUNTYFP %in% msa_fips\n  )\n```\n:::\n\n\nI also want data on U.S. highways. We won't use this data right away but we'll need it later on in this exercise.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nus_highways <- tigris::primary_roads(year = 2020)\n```\n:::\n\n\nNow, I can use the [county FIPS code](https://en.wikipedia.org/wiki/FIPS_county_code) column from `msa` (named `COUNTYFP`) to get crash data using the [{crashapi}](https://elipousson.github.io/crashapi/) package and the National Highway Traffic Safety Administration (NHTSA) [Fatality Analysis Reporting System (FARS) API](https://crashviewer.nhtsa.dot.gov/CrashAPI/).\n\nBelow, I am using `purrr::map_dfr()` allows us to combine results for each county into a single data frame. When `geometry = TRUE`, `crashapi::get_fars_crashes()` is using `sf::st_as_sf()` to convert a data frame into a sf object based on the longitude and latitude columns.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmd_crashes <-\n  purrr::map_dfr(\n    md_counties$COUNTYFP,\n    ~ crashapi::get_fars_crashes(\n      year = 2020,\n      state = md,\n      county = .x,\n      geometry = TRUE\n    )\n  )\n\nmsa_crashes <-\n  filter(\n    md_crashes,\n    county %in% as.integer(msa_fips)\n  )\n```\n:::\n\n\n::: {.callout-tip appearance=\"simple\"}\nIf you're interested in learning more using API packages, check out Ch. 8 [Geographic data I/O](https://geocompr.robinlovelace.net/read-write.html) in @lovelaceGeocomputation2022. For more on the advanced topic of developing API packages, check out [this vignette from the {httr2} package](https://httr2.r-lib.org/articles/wrapping-apis.html) (which is what {crashapi} is using to download data from NHTSA).\n:::\n\n### Mapping data\n\nFor this exercise, we are using the {tmap} package to take a look at the data. Visual checks are often essential to exploring and understanding what the spatial and geometric transformation functions are doing to your data. Similar to ggplot2 plots, you can put the results of a map into an object that you can use as a base map.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"**Show the code** | Map Baltimore MSA boundaries\"}\nmd_borders <-\n  tm_shape(md_counties) +\n  tm_borders(col = \"gray60\")\n\nmsa_borders <-\n  tm_shape(msa_counties) +\n  tm_borders(col = \"gray60\")\n\nmsa_borders +\n  tm_shape(msa_crashes) +\n  tm_dots(col = \"red\", alpha = 0.4)\n## Warning in sf::st_is_longlat(shp2): bounding box has potentially an invalid\n## value range for longlat data\n```\n\n::: {.cell-output-display}\n![](04_spatial-operations-r-crashapi_files/figure-html/tmap_crashes-1.png){width=672}\n:::\n:::\n\n\nWait a moment: did you see spot the warning up there? üëÜüèº It said: \"Warning in sf::st_is_longlat(shp2): bounding box has potentially an invalid value range for longlat data.\"\n\nWhere is that coming from? Let's take a quick look at the data using the base `summary()` function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(msa_crashes)\n##      city             cityname            county           countyname       \n##  Length:229         Length:229         Length:229         Length:229        \n##  Class :character   Class :character   Class :character   Class :character  \n##  Mode  :character   Mode  :character   Mode  :character   Mode  :character  \n##                                                                             \n##                                                                             \n##                                                                             \n##    case_year        fatals         latitude         longitud      \n##  Min.   :2020   Min.   :1.000   Min.   : 38.73   Min.   : -77.17  \n##  1st Qu.:2020   1st Qu.:1.000   1st Qu.: 39.20   1st Qu.: -76.75  \n##  Median :2020   Median :1.000   Median : 39.30   Median : -76.63  \n##  Mean   :2020   Mean   :1.061   Mean   : 39.73   Mean   : -68.20  \n##  3rd Qu.:2020   3rd Qu.:1.000   3rd Qu.: 39.37   3rd Qu.: -76.53  \n##  Max.   :2020   Max.   :3.000   Max.   :100.00   Max.   :1000.00  \n##     state            statename           st_case          totalvehicles  \n##  Length:229         Length:229         Length:229         Min.   :1.000  \n##  Class :character   Class :character   Class :character   1st Qu.:1.000  \n##  Mode  :character   Mode  :character   Mode  :character   Median :1.000  \n##                                                           Mean   :1.629  \n##                                                           3rd Qu.:2.000  \n##                                                           Max.   :8.000  \n##    tway_id            tway_id2            ve_forms             geometry  \n##  Length:229         Length:229         Min.   :1.00   POINT        :229  \n##  Class :character   Class :character   1st Qu.:1.00   epsg:4326    :  0  \n##  Mode  :character   Mode  :character   Median :1.00   +proj=long...:  0  \n##                                        Mean   :1.52                      \n##                                        3rd Qu.:2.00                      \n##                                        Max.   :5.00\n```\n:::\n\n\n‚òùÔ∏è Hint: look at the range of the latitude and longitude columns.\n\nDid you spot the issue? I can use filter to track down the problem:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfilter(\n  msa_crashes,\n  longitud > 180 | latitude > 90 | longitud < -180 | latitude < -90\n  )\n## Warning in st_is_longlat(x): bounding box has potentially an invalid value range\n## for longlat data\n## # A tibble: 2 √ó 16\n##   city  cityname  county countyname case_‚Ä¶¬π fatals latit‚Ä¶¬≤ longi‚Ä¶¬≥ state state‚Ä¶‚Å¥\n##   <chr> <chr>     <chr>  <chr>        <int>  <int>   <dbl>   <dbl> <chr> <chr>  \n## 1 50    BALTIMORE 510    BALTIMORE‚Ä¶    2020      1   100.    1000. 24    Maryla‚Ä¶\n## 2 50    BALTIMORE 510    BALTIMORE‚Ä¶    2020      1    77.8    778. 24    Maryla‚Ä¶\n## # ‚Ä¶ with 6 more variables: st_case <chr>, totalvehicles <int>, tway_id <chr>,\n## #   tway_id2 <chr>, ve_forms <int>, geometry <POINT [¬∞]>, and abbreviated\n## #   variable names ¬π‚Äãcase_year, ¬≤‚Äãlatitude, ¬≥‚Äãlongitud, ‚Å¥‚Äãstatename\n```\n:::\n\n\nTo fix this issue, we need to crop the data to exclude outlying invalid coordinates. Cropping is one of a few geometry operations supported by the sf package. Let's dig in.\n\n## Geometry operations\n\n### Cropping and transforming data\n\nHow can I use `st_crop()` to exclude those incorrectly located crashes? `st_crop()` takes two parameters:\n\n-   `x`: A `sf` or `sfc` object that you want to *crop*\n-   `y`: A `sf`, `sfc`, or `bbox` object (or numeric x and y min/max values) that you want to crop *to*\n\nThis pattern of an `x` and `y` parameter is common across all the geometry operations although, for at least some, the second parameter is optional.\n\nü§î What parameters do you need to crop `msa_crashes`?\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# msa_crashes <- st_crop()\n```\n:::\n\n\nOops. Did you get an error?\n\nHere is the catch: both objects need to use the same coordinate reference system for spatial transformation functions to work. To do this we need to know what coordinate reference system `msa_crashes` is using.\n\nYou can use `st_crs()` to check:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nst_crs(msa_crashes)\n## Coordinate Reference System:\n##   User input: EPSG:4326 \n##   wkt:\n## GEOGCRS[\"WGS 84\",\n##     ENSEMBLE[\"World Geodetic System 1984 ensemble\",\n##         MEMBER[\"World Geodetic System 1984 (Transit)\"],\n##         MEMBER[\"World Geodetic System 1984 (G730)\"],\n##         MEMBER[\"World Geodetic System 1984 (G873)\"],\n##         MEMBER[\"World Geodetic System 1984 (G1150)\"],\n##         MEMBER[\"World Geodetic System 1984 (G1674)\"],\n##         MEMBER[\"World Geodetic System 1984 (G1762)\"],\n##         MEMBER[\"World Geodetic System 1984 (G2139)\"],\n##         ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n##             LENGTHUNIT[\"metre\",1]],\n##         ENSEMBLEACCURACY[2.0]],\n##     PRIMEM[\"Greenwich\",0,\n##         ANGLEUNIT[\"degree\",0.0174532925199433]],\n##     CS[ellipsoidal,2],\n##         AXIS[\"geodetic latitude (Lat)\",north,\n##             ORDER[1],\n##             ANGLEUNIT[\"degree\",0.0174532925199433]],\n##         AXIS[\"geodetic longitude (Lon)\",east,\n##             ORDER[2],\n##             ANGLEUNIT[\"degree\",0.0174532925199433]],\n##     USAGE[\n##         SCOPE[\"Horizontal component of 3D system.\"],\n##         AREA[\"World.\"],\n##         BBOX[-90,-180,90,180]],\n##     ID[\"EPSG\",4326]]\n\n# You can also use st_crs() to get a Spatial Reference identifier (srid) for a coordinate reference system\n# st_crs(msa_crashes)$srid\n```\n:::\n\n\nThen we need to use the `st_transform()` function to change to coordinate reference system of `msa_counties`. The first parameter of `st_transform()` is always the sf or sfc object to transform but the second parameter can be a number, a character, or the output from the `st_crs()` function. For example, both of these calls transform `msa_counties` to the [Pseudo-Mercator](https://epsg.io/3857) coordinate reference system used by Google Maps, OpenStreetMap, and other web maps:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nst_transform(msa_counties, 3857)\n\nst_transform(msa_counties, \"EPSG:3857\")\n```\n:::\n\n\nü§î Now it is your turn to transform `msa_counties`. Fill in the missing parameters:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# msa_counties <- st_transform()\n```\n:::\n\n\nFinally, you can crop `msa_crashes` the way you wanted:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Overwrite msa_crashes w/ cropped data\nmsa_crashes <- st_crop(msa_crashes, msa_counties)\n```\n:::\n\n\nOK. Let's map the cropped `msa_crashes` data:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmsa_borders +\n  tm_shape(msa_crashes) +\n  tm_dots(col = \"red\")\n## Warning in sf::st_is_longlat(shp2): bounding box has potentially an invalid\n## value range for longlat data\n```\n\n::: {.cell-output-display}\n![](04_spatial-operations-r-crashapi_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n\nTake a moment and compare this map with a map of `md_crashes` (which also needs to be cropped). Remember, tmap uses the bounding box of the first sf object passed to `tm_shape()` to set the plot area.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmd_counties <- st_transform(md_counties, st_crs(md_crashes))\n# Crop md_crashes also\nmd_crashes <- st_crop(md_crashes, md_counties)\n\nmsa_borders +\n  tm_shape(md_crashes) +\n  tm_dots(col = \"red\")\n```\n\n::: {.cell-output-display}\n![](04_spatial-operations-r-crashapi_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n\n\nDo you notice the difference between the two maps?\n\nImagine we didn't have couldn't use a county attribute to filter `msa_crashes` from `md_crashes`. How could we get data that is more like the first map?\n\n### Getting the intersection or difference between pairs of simple features\n\nLet's try out `st_intersection()`. Like `st_crop()`, this function takes two parameters but works a more like a cookie cutter---trimming the features of the first parameter to the boundary of the second parameter.\n\nFor example, I can trim `md_crashes` to the boundary of Baltimore City.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmd_counties <- st_transform(md_counties, st_crs(md_crashes))\nmsa_counties <- st_transform(msa_counties, st_crs(md_crashes))\n\nbaltimore_city <- msa_counties[7,]\n\nbaltimore_crashes <- st_intersection(md_crashes, baltimore_city)\n## Warning: attribute variables are assumed to be spatially constant throughout all\n## geometries\n```\n:::\n\n\nThe function did a little more than just exclude the crashes outside Baltimore City. The names and attributes for any intersecting features from the second parameter have been joined to the features from the first parameter. You can actually get the same result using the `st_join()` function when `left = FALSE`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbaltimore_crashes_join <- st_join(md_crashes, baltimore_city, left = FALSE, join = st_intersects)\n\n# all.equal tests if two objects are (nearly) equal\nall.equal(baltimore_crashes, baltimore_crashes_join)\n## [1] TRUE\n```\n:::\n\n\n`st_difference()` works more like an eraser---selectively removing a specific area.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncrashes_outside_baltimore <- st_difference(md_crashes, baltimore_city)\n## Warning: attribute variables are assumed to be spatially constant throughout all\n## geometries\n```\n:::\n\n\nI can map the data to take a look at the results:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nmsa_borders +\n  tm_shape(baltimore_crashes) +\n  tm_dots(col = \"orange\") +\n  tm_shape(crashes_outside_baltimore) +\n  tm_dots(col = \"red\")\n```\n\n::: {.cell-output-display}\n![](04_spatial-operations-r-crashapi_files/figure-html/unnamed-chunk-15-1.png){width=672}\n:::\n:::\n\n\nü§î Now, your turn. Can you use `st_intersection()` to trim the crash data to Anne Arundel County?\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# anne_arundel_crashes <- \n```\n:::\n\n\nü§î Can you map the Anne Arundel County crashes over top of a crash map for the full state?\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# md_borders +\n#   tm_shape(anne_arundel_crashes) +\n#   tm_dots()\n```\n:::\n\n\nü§î Bonus question: can you figure out how many fatalities occurred in Anne Arundel County? Remember, the number of fatalities may not be the same as fatal crashes. Try using the `nrow()` and `sum()` functions to determine these numbers.\n\n\n::: {.cell}\n\n:::\n\n\nIf you the intersection worked as expected, you should find **50 crashes** and **50 fatalities**.\n\n## Geometric operations\n\nOK. Let's try something different. Remember those highways? The data covers the entire U.S. but we just need the highways for Maryland.\n\nThis time, I'll use the `st_filter()` function with the default `st_intersects()` predicate (we will come back to predicate functions at the end):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nus_highways <- st_transform(us_highways, st_crs(md_crashes))\n\nmd_highways <- st_filter(us_highways, md_counties, .predicate = st_intersects)\n```\n:::\n\n\nAs usual, a map is helpful to make sure this worked the way I expected:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"**Show the code** | Map Maryland Highways\"}\nmd_borders +\n  tm_shape(md_highways) +\n  tm_lines(col = \"darkgreen\")\n```\n\n::: {.cell-output-display}\n![](04_spatial-operations-r-crashapi_files/figure-html/unnamed-chunk-20-1.png){width=672}\n:::\n:::\n\n\nNow that we have highways, could we use `st_filter()` to get highway crashes? Give it a try:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nst_filter(md_crashes, md_highways)\n## # A tibble: 0 √ó 16\n## # ‚Ä¶ with 16 variables: city <chr>, cityname <chr>, county <chr>,\n## #   countyname <chr>, case_year <int>, fatals <int>, latitude <dbl>,\n## #   longitud <dbl>, state <chr>, statename <chr>, st_case <chr>,\n## #   totalvehicles <int>, tway_id <chr>, tway_id2 <chr>, ve_forms <int>,\n## #   geometry <GEOMETRY [¬∞]>\n```\n:::\n\n\nWell, that didn't work. The highways are a LINESTRING feature so it isn't the most effective spatial filter. Using `st_buffer()` we can add a little space around each highway and try again.\n\nHow does `st_buffer()` work? Using the `dist` (short dor distance) parameter you can add space around a point, linestring, or polygon.\n\n::: {.callout-important appearance=\"simple\"}\nThis can get a little complicated depending on your coordinate reference system. When using the [GEOS library](https://libgeos.org/), the units for `dist` are degrees for geometric coordinate reference systems (e.g. EPSG:4326) or the system's native units (most often feet or meters) for projected coordinate reference systems. But, when you are using the [s2geometry library](https://s2geometry.io/), `dist` is passed to the `s2::s2_buffer_cells()` function where the units are determined by the units used by the `radius` parameter (which defaults to meters). It can be helpful to use the `units::set_units()` function that makes it easier to set the buffer in whatever distance you like and then convert to the needed units.\n:::\n\nFor this exercise, let's convert our data projected CRS so we can use the version of `st_buffer()` that works with GEOS.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"**Show the code** | Transform data to a projected CRS\"}\nmd_crashes <- st_transform(md_crashes, 3857)\nmd_counties <- st_transform(md_counties, 3857)\nmsa_crashes <- st_transform(msa_crashes, 3857)\nmsa_counties <- st_transform(msa_counties, 3857)\nmd_highways <- st_transform(md_highways, 3857)\n```\n:::\n\n\nNow, I can add a buffer:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-summary=\"Buffer Maryland highways\"}\nmd_highways_quartermi <-\n  st_buffer(\n    md_highways,\n    dist = 402.336 # quarter-mile in m\n  )\n\nmd_highways_halfmi <-\n  st_buffer(\n    md_highways,\n    dist = units::set_units(0.5, \"mi\") %>% \n      units::set_units(\"m\")\n  )\n```\n:::\n\n\nI'll map the data to show that it works (using Baltimore County to set the map bounding box so it easier to see the difference between the two buffers).\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"**Show the code** | Map bufferred Maryland highways\"}\ntm_shape(msa_counties, bbox = msa_counties[7,]) +\n  tm_borders(col = \"gray60\") +\n  tm_shape(md_highways_quartermi) +\n  tm_borders(col = \"blue\") +\n  tm_shape(md_highways_halfmi) +\n  tm_borders(col = \"purple\")\n```\n\n::: {.cell-output-display}\n![](04_spatial-operations-r-crashapi_files/figure-html/unnamed-chunk-24-1.png){width=672}\n:::\n:::\n\n\nü§î A half mile buffer seems too large. Can you add a 250 meter buffer to the `md_highways`?\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# md_highways_250m <- st_buffer()\n```\n:::\n\n\nThen, go back and filter crash data using `md_highways_250m`. How many fatal crashes took place within 250 meters of a highway in Maryland? How many fatalities?\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# st_filter()\n```\n:::\n\n\nYou should find **96 crashes** and **99 fatalities**.\n\n## Confirming geometric relationships\n\nThere is also a set of related functions called \"predicates\" or geometric confirmation functions that take pairs of simple feature geometry sets and return an index list or logical matrix based on the spatial relationship between the features. For example, `st_intersects()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nst_intersects(msa_counties, md_counties, sparse = FALSE)\n##       [,1]  [,2]  [,3]  [,4]  [,5]  [,6]  [,7]  [,8]  [,9] [,10] [,11] [,12]\n## [1,]  TRUE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE\n## [2,] FALSE FALSE FALSE  TRUE FALSE FALSE  TRUE  TRUE FALSE FALSE FALSE FALSE\n## [3,] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE\n## [4,] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n## [5,] FALSE FALSE FALSE  TRUE FALSE FALSE  TRUE FALSE FALSE FALSE  TRUE FALSE\n## [6,] FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE  TRUE FALSE FALSE\n## [7,] FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE\n##      [,13] [,14] [,15] [,16] [,17] [,18] [,19] [,20] [,21] [,22] [,23] [,24]\n## [1,] FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE\n## [2,] FALSE FALSE FALSE FALSE FALSE  TRUE FALSE  TRUE FALSE FALSE FALSE  TRUE\n## [3,] FALSE  TRUE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE\n## [4,] FALSE FALSE  TRUE FALSE  TRUE  TRUE FALSE  TRUE FALSE FALSE FALSE FALSE\n## [5,] FALSE FALSE  TRUE FALSE  TRUE  TRUE FALSE  TRUE FALSE FALSE FALSE FALSE\n## [6,] FALSE FALSE  TRUE FALSE FALSE  TRUE FALSE  TRUE FALSE FALSE FALSE  TRUE\n## [7,] FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE  TRUE\n```\n:::\n\n\nWhat is this matrix? The function is comparing each element of x (`msa_counties`) to each element of `y` (`md_counties`). We can simplify the function by using `st_union()` on the second argument:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmd_counties_union <- st_union(md_counties)\n\nst_intersects(msa_counties, md_counties_union, sparse = FALSE)\n##      [,1]\n## [1,] TRUE\n## [2,] TRUE\n## [3,] TRUE\n## [4,] TRUE\n## [5,] TRUE\n## [6,] TRUE\n## [7,] TRUE\n```\n:::\n",
    "supporting": [
      "04_spatial-operations-r-crashapi_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}